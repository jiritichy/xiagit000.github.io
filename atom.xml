<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Roc&#39;s Blog</title>
  
  <subtitle>Good good study, day day up!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://wsznd.com/"/>
  <updated>2021-06-23T09:09:12.483Z</updated>
  <id>https://wsznd.com/</id>
  
  <author>
    <name>夏鹏</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>java性能浅谈-虚拟机篇</title>
    <link href="https://wsznd.com/2021/06/22/java%E6%80%A7%E8%83%BD%E6%B5%85%E8%B0%88-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AF%87/"/>
    <id>https://wsznd.com/2021/06/22/java性能浅谈-虚拟机篇/</id>
    <published>2021-06-22T07:50:22.000Z</published>
    <updated>2021-06-23T09:09:12.483Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>关于java的性能问题，涵盖的面相当广泛，从本地程序到web、分布式、大数据都有很多方面值得注意和推敲，本次仅结合java虚拟机相关的基础知识探讨下平时开发和部署过程中遇到的问题和需要注意的细节点。</p><p>对于Java程序员来说， 在虚拟机的自动内存管理机制的帮助下，不再需要为每一个new操作去写配对的delete/free代码，而且不容易出现内存泄漏和内存溢出问题，看起来由虚拟机管理内存一切都很美好。不过，也正是因为Java程序员把内存控制的权力交给了Java虚拟机，一旦出现内存泄漏和溢出方面的问题， 如果不了解虚拟机是怎样使用内存的， 那排查错误将会成为一项异常艰难的工作。</p><a id="more"></a><h1 id="JVM虚拟机基础知识"><a href="#JVM虚拟机基础知识" class="headerlink" title="JVM虚拟机基础知识"></a>JVM虚拟机基础知识</h1><h2 id="运行时的数据区域"><a href="#运行时的数据区域" class="headerlink" title="运行时的数据区域"></a>运行时的数据区域</h2><p>Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。 这些区域都有各自的用途， 以及创建和销毁的时间，有的区域随着虚拟机进程的启动而存在， 有些区域则是依赖用户线程的启动和结束而建立和销毁。</p><img src="/2021/06/22/java性能浅谈-虚拟机篇/1.png"><blockquote><p><strong>方法区</strong>：为了便于理解可以简单地认为它就是存放静态数据的位置，也就是所谓的永久代，但是实际上<br>这个区域是虚拟机规范最为宽松的位置，可以有各种实现，甚至不实现而使用直接内存，进入该区域的<br>数据也并不是真的永久存在，gc在该区域发生的很少，常量池回收和类型卸载依然会存在。  </p></blockquote><blockquote><p><strong>虚拟机栈(stack)</strong>：它所描述的内存模型：每个方法被执行的时候都会同时创建一个栈帧用于存储局部变量表、操作栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。<br>简单来讲，对应到web应用就是处理用户请求的线程区域，他是线程私有的。</p></blockquote><blockquote><p>本地方法栈：与虚拟机栈原理一样，区别在于它为java本地库的执行服务。</p></blockquote><blockquote><p><strong>堆（heap）</strong>：它和虚拟机栈一样，使我们在开发中经常会遇到的字眼，也是内存异常最多的区域之一。它简单的理解就是存放对象实例，它是被所有线程共享的，垃圾回收的主要区域也在这里。</p></blockquote><blockquote><p>程序计数器：它的作用可以看做是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。简单理解一句话，控制代码的运行逻辑。这也是jvm运行区域里面唯一不存在内存泄漏情况的区域，平时开发过程中基本不需要关注。</p></blockquote><p>结合上面的简单介绍，我们现在大致应该清楚jvm里面三个最为重要的内存区域就是java栈，java堆和方法区，后面所有的分享将会围绕这三个重点区域展开。</p><h1 id="对象访问"><a href="#对象访问" class="headerlink" title="对象访问"></a>对象访问</h1><p>接下来看下我们最为常见的新建对象及对象的访问在虚拟机都发生了什么。</p><h2 id="对象初始化时发生了什么"><a href="#对象初始化时发生了什么" class="headerlink" title="对象初始化时发生了什么"></a>对象初始化时发生了什么</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure><p>如果这句代码出现在方法体中，“Object obj”这部分的语义会反映到java栈的变量表中，作为一个引用（Reference）类型数据出现，而“new Object()”这部分的语义将会反映到java堆中，形成一块存储Object类型所有实例数据值的结构化内存，此外java堆必须包含能查到此对象类型数据的地址信息。</p><h2 id="访问对象是如何进行的"><a href="#访问对象是如何进行的" class="headerlink" title="访问对象是如何进行的"></a>访问对象是如何进行的</h2><p>由于引用（reference）类型在jvm里面只是一种规范，至于这个引用怎么实现，不同的虚拟机会有不同的实现方式，比较主流的有两种：句柄和直接指针。</p><ul><li>如果使用句柄的方式访问，java堆中将会划分中一块内存在作为句柄池，引用中存储的就是对象的句柄地址，二局并重包含了该对象所有数据的地址信息。</li></ul><img src="/2021/06/22/java性能浅谈-虚拟机篇/2.png"><ul><li>如果使用直接指针进行访问，java堆对象的的布局就得考虑如何把需要访问的类型数据放置好，引用中存储的就是对象的句柄存储的就是对象的地址。</li></ul><img src="/2021/06/22/java性能浅谈-虚拟机篇/3.png"><p>综上，这两种方式各有优劣，句柄访问最大的好处就是变量表存储的是稳定的句柄地址，对象被移动时只会改变句柄中实例数据指针，而栈里面的引用本身是不需要被修改的。</p><p>而指针访问最大的好处就是快，节省了一次指针定位的开销，对象的访问在java中是非常频繁的，这在性能提升方面是非常具有优势的。</p><h1 id="常见的内存异常（OutOfMemoryError）"><a href="#常见的内存异常（OutOfMemoryError）" class="headerlink" title="常见的内存异常（OutOfMemoryError）"></a>常见的内存异常（OutOfMemoryError）</h1><ul><li>OutOfMemoryError: java heap space…</li><li>StackOverflowError</li><li>OutOfMemoryError: new native thread</li><li>OutOfMemoryError: PermGen space</li></ul><p>java堆溢出（OutOfMemoryError: java heap space…）<br>实例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 堆溢出</span></span><br><span class="line"><span class="comment"> * VM Args：- Xms20m -Xmx20m -XX:+ HeapDumpOnOutOfMemoryError</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapOOM</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exec</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> Object());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        exec();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>java栈及本地方法栈溢出（StackOverflowError），如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出该异常，单个线程下，无论是栈帧太大还是栈容量太小（Xss）,当内存无法分配的时候，虚拟机都是抛出StackOverflowError的异常。<br>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 栈帧溢出</span></span><br><span class="line"><span class="comment"> * VM Args: -Xss160k</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">exec</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    exec();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    StackLeak sl = <span class="keyword">new</span> StackLeak();</span><br><span class="line">    sl.exec();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建多线程导致内存溢出（OutOfMemoryError: new native thread），一般情况下，给每个线程的栈分配的内存越大，当线程数增多的时候越容易产生内存溢出的异常<br>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程内存溢出</span></span><br><span class="line"><span class="comment"> * VM Args: -Xss160k</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackOOM</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">noStop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">30000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exec</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(() -&gt; noStop());</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StackOOM so = <span class="keyword">new</span> StackOOM();</span><br><span class="line">        so.exec();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行时常量池溢出（OutOfMemoryError: PermGen space），如果要向运行时的常量池中添加内容，最简单的做法就是使用String.intern()这个Native方法。该方法的作用是：如果翅中已经包含一个等于此对象的字符串，则返回这个对象，否则，将该对象添加到常量池中。<br>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">"sss"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 常量池内存溢出</span></span><br><span class="line"><span class="comment"> * VM Args：- XX: PermSize= 10M -XX: MaxPermSize= 10M (java1.7及以下版本)</span></span><br><span class="line"><span class="comment"> * VM Args: -XX:MetaspaceSize=10M -XX:MaxMetaspaceSize=10M （java1.8及以上版本）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">exec</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        str = str + str;</span><br><span class="line">        list.add(str.intern());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ConstantPoolOOM cp = <span class="keyword">new</span> ConstantPoolOOM();</span><br><span class="line">    cp.exec();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="内存分配与垃圾回收策略"><a href="#内存分配与垃圾回收策略" class="headerlink" title="内存分配与垃圾回收策略"></a>内存分配与垃圾回收策略</h1><p>垃圾回收的算法其实有很多种，譬如常见的引用计数算法和跟搜索算法，感兴趣的朋友可以自行了解，这里不做展开。这里主要强调作为开发者必须要了解的垃圾回收机制及相应的规则。</p><h2 id="内存回收区域"><a href="#内存回收区域" class="headerlink" title="内存回收区域"></a>内存回收区域</h2><p>内存回收区域大致分为新生代（包含eden和survivor）区域和老年代区域，对应的回收分别为minor GC和major GC（full GC）,分别对应的含义：</p><ul><li>Eden，新生对象内存分配的区域</li><li>survivor，可以理解为缓冲区，避免内存大量涌入老年代，导致full GC</li><li>old， 长时间存活的对象及大文件连续内存存放的区域</li></ul><p>先来看一段代码，加深理解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** * VM 参数：- verbose: gc -Xms20M -Xmx20M -Xmn10M -XX: SurvivorRatio= 8 */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exec</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">byte</span>[] a1, a2, a3, a4;</span><br><span class="line">  a1 = <span class="keyword">new</span> <span class="keyword">byte</span>[ <span class="number">2</span> * _1MB];</span><br><span class="line">  a2 = <span class="keyword">new</span> <span class="keyword">byte</span>[ <span class="number">2</span> * _1MB];</span><br><span class="line">  a3 = <span class="keyword">new</span> <span class="keyword">byte</span>[ <span class="number">2</span> * _1MB];</span><br><span class="line">  a4 = <span class="keyword">new</span> <span class="keyword">byte</span>[ <span class="number">5</span> * _1MB];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对象优先在Eden（新生代）分配"><a href="#对象优先在Eden（新生代）分配" class="headerlink" title="对象优先在Eden（新生代）分配"></a>对象优先在Eden（新生代）分配</h2><p>大多数情况下，对象在新生代Eden区中分配。 当Eden区没有足够的空间进行分配时， 虚拟机 将发起一次Minor GC，也就是回收新生代的内存。</p><p>虚拟机提供了-XX: +PrintGCDetails收集器日志参数，可以打印回收日志。</p><h2 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h2><p>所谓的大对象就是指需要大量连续内存空间的java对象，大量的生存周期很短的大对象进入内存，会导致内存空间足够的情况下，频繁触发垃圾回收。</p><p>虚拟机提供了一个-XX:PretenureSIzeThreshold参数可以让大于这个设置值的对象直接在老年代分配，这样是为了避免在Eden和Survivor区域出现大量且频繁的内存拷贝</p><h2 id="长期存活的对象进入老年代"><a href="#长期存活的对象进入老年代" class="headerlink" title="长期存活的对象进入老年代"></a>长期存活的对象进入老年代</h2><p>这个顾名思义，比较好理解，内存分代收集进行管理，目的也在于此。参数MaxTenuringThreshold可以用来设置新生代经历多少次Minor GC才能够被转移到老年代</p><p><strong>更加进阶的概念包括动态对象年龄判定，空间分配担保这里就留给大家自行研究理解</strong></p><h1 id="场景探讨"><a href="#场景探讨" class="headerlink" title="场景探讨"></a>场景探讨</h1><ol><li>系统导入大文件时频繁出现系统卡死无响应甚至崩溃的原因分析。</li><li>服务器不定时发生内存溢出，但是java堆日志和虚拟机监控均发现不了任何问题。</li><li>服务器虚拟机进程自动关闭，且报出SocketException: Connection reset的异常。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;关于java的性能问题，涵盖的面相当广泛，从本地程序到web、分布式、大数据都有很多方面值得注意和推敲，本次仅结合java虚拟机相关的基础知识探讨下平时开发和部署过程中遇到的问题和需要注意的细节点。&lt;/p&gt;
&lt;p&gt;对于Java程序员来说， 在虚拟机的自动内存管理机制的帮助下，不再需要为每一个new操作去写配对的delete/free代码，而且不容易出现内存泄漏和内存溢出问题，看起来由虚拟机管理内存一切都很美好。不过，也正是因为Java程序员把内存控制的权力交给了Java虚拟机，一旦出现内存泄漏和溢出方面的问题， 如果不了解虚拟机是怎样使用内存的， 那排查错误将会成为一项异常艰难的工作。&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="https://wsznd.com/categories/java/"/>
    
    
      <category term="java" scheme="https://wsznd.com/tags/java/"/>
    
      <category term="性能" scheme="https://wsznd.com/tags/%E6%80%A7%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>Spring Restdocs使用指南</title>
    <link href="https://wsznd.com/2019/08/12/spring-restdocs%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    <id>https://wsznd.com/2019/08/12/spring-restdocs使用指南/</id>
    <published>2019-08-12T01:59:34.000Z</published>
    <updated>2021-06-23T09:21:06.787Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文旨在介绍Spring restdocs的相关用法，在这之前需要对restful有比较全面的了解，哪怕仅仅只是概念上的，所以接下来在介绍restdocs的使用方法前，得先简单的概述下restful相关的知识。</p><a id="more"></a><h1 id="Rest架构介绍"><a href="#Rest架构介绍" class="headerlink" title="Rest架构介绍"></a>Rest架构介绍</h1><h2 id="什么是Rest？"><a href="#什么是Rest？" class="headerlink" title="什么是Rest？"></a>什么是Rest？</h2><blockquote><ol><li>REST 是 Representational state transfer 的缩写，翻译为表达性状态转换。</li><li>REST 是一种架构风格，它包含了一个分布式超文本系统中对于组件、连接器和数据的约束。</li><li>REST 是作为互联网自身架构的抽象而出现的，其关键在于所定义的架构上的各种约束。</li></ol></blockquote><p>只有满足这些约束，才能称之为符合 REST 架构风格</p><h2 id="为什么要使用Rest"><a href="#为什么要使用Rest" class="headerlink" title="为什么要使用Rest"></a>为什么要使用Rest</h2><p>从实用角度讲，现在的互联网应用通常都是一个数据服务对应多个客户端，这些客户端可能分布于其它各个平台，Restful以http协议调用的方式提供一套统一的接口为各个客户端提供服务，为各个平台提供相同的使用体验，同时restful带有自描述的特征，根据action和method我们就可以知道接口需要做什么事情。</p><p>从技术角度讲restful可以让前端知道的更少，减少硬编码的数量，做到更加的智能和自适应。</p><h2 id="Rest的成熟模型"><a href="#Rest的成熟模型" class="headerlink" title="Rest的成熟模型"></a>Rest的成熟模型</h2><p>REST 成熟度模型把 REST 服务按照成熟度划分成 4 个层次（成熟度由低到高）：</p><blockquote><p><strong>第一层次（Level 0）的 Web 服务只是使用 HTTP 作为传输方式，实际上只是远程方法调用（RPC）的一种具体形式。SOAP 和 XML-RPC 都属于此类</strong><br><strong>第二层次（Level 1）的 Web 服务引入了资源的概念。每个资源有对应的标识符和表达</strong><br><strong>第三层次（Level 2）的 Web 服务使用不同的 HTTP 方法来进行不同的操作，并且使用 HTTP 状态码来表示不同的结果，如：HTTP GET 方法来获取资源，HTTP DELETE 方法来删除资源</strong><br><strong>第四层次（Level 3）的 Web 服务使用 HATEOAS。在资源的表达中包含了链接信息，客户端可根据链接来发现可执行的动作。</strong></p></blockquote><h2 id="啥是HATEOAS？"><a href="#啥是HATEOAS？" class="headerlink" title="啥是HATEOAS？"></a>啥是HATEOAS？</h2><p><a href="https://spring.io/projects/spring-hateoas" target="_blank" rel="noopener">Spring HATEOAS</a> 是一个用于支持实现超文本驱动的 REST Web 服务的开发库。是 HATEOAS 的实现，HATEOAS背后的思想就是响应中包含指向其它资源的链接，客户端可以利用这些链接和服务器交互。</p><img src="/2019/08/12/spring-restdocs使用指南/1.png"><p><strong>常用的非HATEOAS请求响应：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /posts/1 HTTP/1.1</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Host: example.ycb.com</span><br><span class="line">&#123;</span><br><span class="line">    &quot;id&quot; : 1,</span><br><span class="line">    &quot;body&quot; : &quot;My first blog post&quot;,</span><br><span class="line">    &quot;postdate&quot; : &quot;2015-05-30T21:41:12.650Z&quot;</span><br><span class="line">￼&#125;</span><br></pre></td></tr></table></figure><p><strong>HATEOAS的响应例子：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&quot;id&quot; : 1,</span><br><span class="line">&quot;body&quot; : &quot;My first blog post&quot;,</span><br><span class="line">&quot;postdate&quot; : &quot;2015-05-30T21:41:12.650Z&quot;,</span><br><span class="line">&quot;links&quot; : [</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;rel&quot; : &quot;self&quot;,</span><br><span class="line">        &quot;href&quot; : http://example.ycb.com/posts/1,</span><br><span class="line">        &quot;method&quot; : &quot;GET&quot;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>上面的例子中，每一个在links中的link都包含了三部分：</p><blockquote><p>href：用户可以用来检索资源或者改变应用状态的URI<br>rel：描述href指向的资源和现有资源的关系<br>method：和此URI需要的http方法</p></blockquote><p><strong>HATEOAS（Hypermedia as the engine of application state）是 REST 架构风格中最复杂的约束，也是构建成熟 REST 服务的核心，它的重要性在于打破了客户端和服务器之间严格的契约，使得客户端可以更加智能和自适应，而 REST 服务本身的演化和更新也变得更加容易。</strong></p><h1 id="Rest-docs介绍"><a href="#Rest-docs介绍" class="headerlink" title="Rest docs介绍"></a>Rest docs介绍</h1><p>Spring REST Docs的目的是帮助您为RESTful服务生成准确且可读的文档。</p><p>编写高质量的文档很困难。缓解这种困难的唯一方法是使用非常适合的工具。为此，Spring REST Docs 默认使用 <a href="https://asciidoctor.org/docs/asciidoc-syntax-quick-reference" target="_blank" rel="noopener">Asciidoctor</a>。Asciidoctor处理纯文本并生成HTML，样式和布局以满足您的需求。如果您愿意，还可以将Spring REST Docs配置为使用Markdown。</p><p>Spring REST Docs使用由Spring MVC的测试框架，Spring WebFlux WebTestClient或 REST Assured 3编写的测试产生的片段 。这种以测试为导向的方法有助于保证服务文档的准确性。如果代码段不正确，则生成代码段的测试将失败。</p><p>记录RESTful服务主要是描述其资源。每个资源描述的两个关键部分是它消耗的HTTP请求的详细信息以及它产生的HTTP响应。Spring REST Docs允许您使用这些资源以及HTTP请求和响应，从而使您的文档免受服务实现的内部细节的影响。这种分离可以帮助您记录服务的API而不是其实现。关于API的变动我们不需要对文档做出任何改动。</p><h2 id="官网地址"><a href="#官网地址" class="headerlink" title="官网地址"></a>官网地址</h2><p><a href="https://spring.io/projects/spring-restdocs" title="https://spring.io/projects/spring-restdocs" target="_blank" rel="noopener">https://spring.io/projects/spring-restdocs</a></p><h2 id="Rest-docs-VS-Swagger"><a href="#Rest-docs-VS-Swagger" class="headerlink" title="Rest docs VS Swagger"></a>Rest docs VS Swagger</h2><p>Restdocs和swagger都是当今很主流的技术文档自动生成工具，他们在某些技术层面有相似的成本，他们也同样的优秀，这里我无法比较到底谁更好，但是可以谈谈我在选择文档工具时几个考虑的点，提供大家参考：</p><ol><li><p><strong>重所周知swagger在java里面生成文档，是需要在controller里面添加注释的，如果接口改动足够频繁，修改的范围足够广，很难保证开发者在此过程中不会遗漏，而且分散在各个controller的注解修改本身也会是一件头疼的事情，而rest docs则是以测试用例为导向，在保证接口的可用及正确性的前提下，同时也规范了开发流程，api接口的代码改动将会通过测试代码自动修正，可谓是一举两得。</strong></p></li><li><p><strong>Rest docs会将每个请求的各个部分生成不同的代码片段，同时使用asciidoc进行文档编写，它可以使得文档的生成有更多的选择，更加灵活，而且专业性及可读性也会更胜一筹。</strong></p></li><li><p><strong>最为关键的一点在于，通过测试用例的方式生成文档使得在分布式系统的场景下各个应用的接口文档生成在统一应用下成为可能，它纯粹以模拟用户请求的方式来解析api的各个环节，这样就避免的文档工具与代码本身的紧耦合，我们可以方便的决定我们的文档应该放置于什么地方进行集中编写和管理。</strong></p></li><li><p><strong>restdocs性能更好，它的特性使得文档生成与每个服务的代码没有耦合，可以方便我们在不同的场景下处理文档的生成及访问规则，安全性也更好。</strong></p></li></ol><p>以上使我在选择文档工具着重考量的几个点，如果还有其它方面的问题欢迎大家补充。</p><h1 id="Rest-docs的使用"><a href="#Rest-docs的使用" class="headerlink" title="Rest docs的使用"></a>Rest docs的使用</h1><p>本文的使用方法以spring cloud项目为例，可以为大家在分布式系统架构下面使用文档生成工具提供一些参考，其中讲解及演示的部分仅限于项目所需要的部分，完整的使用指导请参考官方文档。</p><h2 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h2><p>pom.xml:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.restdocs&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-restdocs-mockmvc&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="variable">$&#123;restdocs.version&#125;</span>&lt;/version&gt;</span><br><span class="line">    &lt;scope&gt;<span class="built_in">test</span>&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&lt;plugin&gt;</span><br><span class="line">    &lt;groupId&gt;org.asciidoctor&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;asciidoctor-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.5.3&lt;/version&gt;</span><br><span class="line">    &lt;executions&gt;</span><br><span class="line">        &lt;execution&gt;</span><br><span class="line">            &lt;id&gt;generate-docs&lt;/id&gt;</span><br><span class="line">            &lt;phase&gt;prepare-package&lt;/phase&gt;</span><br><span class="line">            &lt;goals&gt;</span><br><span class="line">                &lt;goal&gt;process-asciidoc&lt;/goal&gt;</span><br><span class="line">            &lt;/goals&gt;</span><br><span class="line">            &lt;configuration&gt;</span><br><span class="line">                &lt;backend&gt;html&lt;/backend&gt;</span><br><span class="line">                &lt;doctype&gt;book&lt;/doctype&gt;</span><br><span class="line">            &lt;/configuration&gt;</span><br><span class="line">        &lt;/execution&gt;</span><br><span class="line">    &lt;/executions&gt;</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.restdocs&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-restdocs-asciidoctor&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="variable">$&#123;restdocs.version&#125;</span>&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="编写测试用例"><a href="#编写测试用例" class="headerlink" title="编写测试用例"></a>编写测试用例</h2><p>测试用例的编码方案在官方指南里分为多种方案，我们这里采用Junit4 + mockMvc的组合方案，不同的方案用法及限制会有不同，这点需要注意。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">@SpringBootTest(classes = GatewayApplication.class)</span><br><span class="line">public class RestDocTest &#123;</span><br><span class="line">    @Rule</span><br><span class="line">    public JUnitRestDocumentation restDocumentation = new JUnitRestDocumentation();</span><br><span class="line"></span><br><span class="line">    private MockMvc mockMvc;</span><br><span class="line">    @Autowired</span><br><span class="line">    private WebApplicationContext context;</span><br><span class="line"></span><br><span class="line">    @Before</span><br><span class="line">    public void setUp() &#123;</span><br><span class="line">        this.mockMvc = MockMvcBuilders.webAppContextSetup(this.context)</span><br><span class="line">                .apply(</span><br><span class="line">                        documentationConfiguration(this.restDocumentation)</span><br><span class="line">                        .operationPreprocessors()</span><br><span class="line">                        .withResponseDefaults(prettyPrint())</span><br><span class="line">                )</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testAuthenticate() throws Exception &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="生成api文档片段"><a href="#生成api文档片段" class="headerlink" title="生成api文档片段"></a>生成api文档片段</h2><p>项目的结构目录：</p><img src="/2019/08/12/spring-restdocs使用指南/2.png"><p><strong>这个时候我们如果执行了刚才编写的测试用例，reset docs默认会在target的generated-snippets下面生成对应的文档片段。</strong></p><h2 id="编写api文档"><a href="#编写api文档" class="headerlink" title="编写api文档"></a>编写api文档</h2><p>文档模板默认是在src下面的asciidoc目录下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line">.请求参数描述</span><br><span class="line">include::&#123;snippets&#125;/auth/request-parameters.adoc[]</span><br><span class="line"></span><br><span class="line">.request</span><br><span class="line">include::&#123;snippets&#125;/auth/http-request.adoc[]</span><br><span class="line"></span><br><span class="line">.响应数据结构描述</span><br><span class="line">include::&#123;snippets&#125;/auth/response-fields.adoc[]</span><br><span class="line"></span><br><span class="line">.response</span><br><span class="line">include::&#123;snippets&#125;/auth/http-response.adoc[]</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>通过如上的方式可以讲测试阶段生成的代码片段引入到我们自己编写的文档中，我们可以进行灵活的配置及文档的定制。</p><h2 id="生成完整的文档"><a href="#生成完整的文档" class="headerlink" title="生成完整的文档"></a>生成完整的文档</h2><p>项目发布的时候如果执行了package命令，会根据我们自定义的文档模板生成对应的文档，生成后的文档默认是在target下面的generated-docs目录下。</p><p>至此，我们的文档就生成完毕，我们根据自己的实际情况进行部署即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本文旨在介绍Spring restdocs的相关用法，在这之前需要对restful有比较全面的了解，哪怕仅仅只是概念上的，所以接下来在介绍restdocs的使用方法前，得先简单的概述下restful相关的知识。&lt;/p&gt;
    
    </summary>
    
      <category term="spring" scheme="https://wsznd.com/categories/spring/"/>
    
    
      <category term="java" scheme="https://wsznd.com/tags/java/"/>
    
      <category term="spring" scheme="https://wsznd.com/tags/spring/"/>
    
      <category term="restdocs" scheme="https://wsznd.com/tags/restdocs/"/>
    
  </entry>
  
  <entry>
    <title>Spring boot整合jooq</title>
    <link href="https://wsznd.com/2019/07/25/spring-boot%E6%95%B4%E5%90%88jooq/"/>
    <id>https://wsznd.com/2019/07/25/spring-boot整合jooq/</id>
    <published>2019-07-25T07:59:11.000Z</published>
    <updated>2021-06-22T07:01:36.979Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近使用spring cloud做分布式应用的开发，底层准备采用jooq做持久层，因为都是单应用，相互之间没有代码上的耦合，所以没有严格按照三层的设计模式来开发，这个时候jooq的代码生成工具就能极大地提升应用的开发效率，整合的过程中发现网上的帖子要么太过简单，要么言语不详，并没有讲清楚具体的开发细节，所以自己完整的记录一下使用过程。</p><a id="more"></a><blockquote><p>本教程依赖于spring boot框架，spring boot的配置与搭建在这里不做赘述</p></blockquote><h2 id="依赖-amp-配置"><a href="#依赖-amp-配置" class="headerlink" title="依赖&amp;配置"></a>依赖&amp;配置</h2><h3 id="pom-xml"><a href="#pom-xml" class="headerlink" title="pom.xml"></a>pom.xml</h3><p>引入jooq的依赖</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-jooq&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.jooq&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jooq-meta&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.jooq&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jooq-codegen&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">    &lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">        /*用于读取yml配置属性的插件*/</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">            &lt;groupId&gt;it.ozimov&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;yaml-properties-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.1.3&lt;/version&gt;</span><br><span class="line">            &lt;executions&gt;</span><br><span class="line">                &lt;execution&gt;</span><br><span class="line">                    &lt;phase&gt;initialize&lt;/phase&gt;</span><br><span class="line">                    &lt;goals&gt;</span><br><span class="line">                        &lt;goal&gt;<span class="built_in">read</span>-project-properties&lt;/goal&gt;</span><br><span class="line">                    &lt;/goals&gt;</span><br><span class="line">                    &lt;configuration&gt;</span><br><span class="line">                        &lt;files&gt;</span><br><span class="line">                            &lt;file&gt;src/main/resources/application.yml&lt;/file&gt;</span><br><span class="line">                        &lt;/files&gt;</span><br><span class="line">                    &lt;/configuration&gt;</span><br><span class="line">                &lt;/execution&gt;</span><br><span class="line">            &lt;/executions&gt;</span><br><span class="line">        &lt;/plugin&gt;</span><br><span class="line"></span><br><span class="line">        /*jooq的配置插件*/</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">            &lt;groupId&gt;org.jooq&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;jooq-codegen-maven&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="variable">$&#123;jooq.version&#125;</span>&lt;/version&gt;</span><br><span class="line">            &lt;executions&gt;</span><br><span class="line">                &lt;execution&gt;</span><br><span class="line">                    &lt;goals&gt;</span><br><span class="line">                        &lt;goal&gt;generate&lt;/goal&gt;</span><br><span class="line">                    &lt;/goals&gt;</span><br><span class="line">                &lt;/execution&gt;</span><br><span class="line">            &lt;/executions&gt;</span><br><span class="line">            &lt;configuration&gt;</span><br><span class="line">                &lt;jdbc&gt;</span><br><span class="line">                    &lt;driver&gt;<span class="variable">$&#123;spring.datasource.driver-class-name&#125;</span>&lt;/driver&gt;</span><br><span class="line">                    &lt;url&gt;<span class="variable">$&#123;spring.datasource.url&#125;</span>&lt;/url&gt;</span><br><span class="line">                    &lt;user&gt;<span class="variable">$&#123;spring.datasource.username&#125;</span>&lt;/user&gt;</span><br><span class="line">                    &lt;password&gt;<span class="variable">$&#123;spring.datasource.password&#125;</span>&lt;/password&gt;</span><br><span class="line">                &lt;/jdbc&gt;</span><br><span class="line">                &lt;generator&gt;</span><br><span class="line">                    &lt;name&gt;org.jooq.util.DefaultGenerator&lt;/name&gt;</span><br><span class="line">                    &lt;database&gt;</span><br><span class="line">                        &lt;name&gt;org.jooq.util.mysql.MySQLDatabase&lt;/name&gt;</span><br><span class="line">                        &lt;includes /&gt;</span><br><span class="line">                        &lt;inputSchema&gt;<span class="variable">$&#123;my.datasource.schema&#125;</span>&lt;/inputSchema&gt;</span><br><span class="line">                    &lt;/database&gt;</span><br><span class="line">                    &lt;generate&gt;</span><br><span class="line">                        &lt;daos&gt;<span class="literal">true</span>&lt;/daos&gt;</span><br><span class="line">                        &lt;pojos&gt;<span class="literal">true</span>&lt;/pojos&gt;</span><br><span class="line">                        &lt;javaTimeTypes&gt;<span class="literal">true</span>&lt;/javaTimeTypes&gt;</span><br><span class="line">                    &lt;/generate&gt;</span><br><span class="line">                    &lt;target&gt;</span><br><span class="line">                        &lt;packageName&gt;your package name&lt;/packageName&gt;</span><br><span class="line">                        &lt;directory&gt;target dir <span class="keyword">for</span> your code generated&lt;/directory&gt;</span><br><span class="line">                    &lt;/target&gt;</span><br><span class="line">                &lt;/generator&gt;</span><br><span class="line">            &lt;/configuration&gt;</span><br><span class="line">        &lt;/plugin&gt;</span><br><span class="line">    &lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="application-yml"><a href="#application-yml" class="headerlink" title="application.yml"></a>application.yml</h3><p>相关的配置如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    url: &#123;&#123;your database url&#125;&#125;</span><br><span class="line">    username: &#123;&#123;your username&#125;&#125;</span><br><span class="line">    password: &#123;&#123;your password&#125;&#125;</span><br><span class="line">    driver-class-name: com.mysql.jdbc.Driver</span><br><span class="line">  jooq:</span><br><span class="line">    sql-dialect: mysql</span><br><span class="line"></span><br><span class="line">my:</span><br><span class="line">  datasource:</span><br><span class="line">    schema: &#123;&#123;your database schema&#125;&#125;</span><br></pre></td></tr></table></figure><p>至此jooq的基本配置已经完成。</p><h2 id="生成代码"><a href="#生成代码" class="headerlink" title="生成代码"></a>生成代码</h2><p>这个时候就需要我们在数据库里面创建业务表，完成以后执行mvn compile命令jooq自动进行逆向操作，根据刚创建的数据表生成java代码。<br>生成完成的代码结构如图：</p><img src="/2019/07/25/spring-boot整合jooq/1.png"><p>生成的代码包含数据库对应的实体，查询映射，还有dao层工具。</p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><h3 id="实体"><a href="#实体" class="headerlink" title="实体"></a>实体</h3><p>按照jooq的基本用法即可，省去了自己手动创建标准对象类的功夫，但是有个弊端就是jooq生成的代码，你是无法改动的，因为下一次使用maven编译的时候会将所有生成的代码进行覆盖，因此如果需要对jooq生成的对象做改动，尽量灵活使用继承，组合的方式进行增强。</p><h3 id="dao层的用法"><a href="#dao层的用法" class="headerlink" title="dao层的用法"></a>dao层的用法</h3><p>jooq生成的dao层提供了很多查询方法，但这些方法对于我们某些业务来说肯定是远远不够的，这就要求我们必须在此基础上添加自定的dao方法，既可以享受jooq已经生成的方法的便利，又可以自定义特定的数据库操作，一举多得。<br>首先我们要自定义一个自己的dao类继承jooq生成的dao类，作为增强类，同时还要把spring已经实例化的jooq configuration注入到父类里面，这样通过增强类去调用继承的方法时，才能正常查询，否则jooq生成的dao类会因为无法获取正确的配置实例而报空指针错误，示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Repository</span><br><span class="line">public class UserDaoExt extends UsersDao implements BaseDao &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private DSLContext create;</span><br><span class="line"></span><br><span class="line">    /*讲spring托管的jooq配置注入到继承的父类当中*/</span><br><span class="line">    @Autowired</span><br><span class="line">    public UserDaoExt(Configuration configuration) &#123;</span><br><span class="line">        super(configuration);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    根据业务需要添加自定义的数据库操作函数</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此jooq的整合就已经基本完成，再往上层调用就跟传统的使用方式一样，不需要再关注持久层的实现。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最近使用spring cloud做分布式应用的开发，底层准备采用jooq做持久层，因为都是单应用，相互之间没有代码上的耦合，所以没有严格按照三层的设计模式来开发，这个时候jooq的代码生成工具就能极大地提升应用的开发效率，整合的过程中发现网上的帖子要么太过简单，要么言语不详，并没有讲清楚具体的开发细节，所以自己完整的记录一下使用过程。&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="https://wsznd.com/categories/java/"/>
    
      <category term="spring" scheme="https://wsznd.com/categories/java/spring/"/>
    
    
      <category term="java" scheme="https://wsznd.com/tags/java/"/>
    
      <category term="spring" scheme="https://wsznd.com/tags/spring/"/>
    
      <category term="jooq" scheme="https://wsznd.com/tags/jooq/"/>
    
  </entry>
  
  <entry>
    <title>Maven3 常用命令</title>
    <link href="https://wsznd.com/2019/07/10/maven%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>https://wsznd.com/2019/07/10/maven常用命令/</id>
    <published>2019-07-10T10:05:07.000Z</published>
    <updated>2021-06-22T07:01:36.978Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-创建项目"><a href="#1-创建项目" class="headerlink" title="1. 创建项目"></a>1. 创建项目</h3><p>命令格式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mvn archetype:generate 固定格式</span><br><span class="line">-DgroupId　组织标识（包名）</span><br><span class="line">-DartifactId　项目名称</span><br><span class="line">-DarchetypeArtifactId 指定ArchetypeId，maven-archetype-quickstart，创建一个Java Project；</span><br><span class="line">maven-archetype-webapp，创建一个Web Project</span><br><span class="line">-DinteractiveMode　是否使用交互模式</span><br><span class="line">-DarchetypeCatalog=<span class="built_in">local</span> 离线模式</span><br></pre></td></tr></table></figure><a id="more"></a><p>创建标准应用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mvn archetype:generate -DgroupId=com.mycompany.app -DartifactId=my-app </span><br><span class="line">-DarchetypeArtifactId=maven-archetype-quickstart -DinteractiveMode=<span class="literal">false</span> -DarchetypeCatalog=<span class="built_in">local</span></span><br></pre></td></tr></table></figure><p>创建web应用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mvn archetype:generate -DgroupId=com.mycompany.app -DartifactId=my-web-app </span><br><span class="line">-DarchetypeArtifactId=maven-archetype-webapp -DinteractiveMode=<span class="literal">false</span> -DarchetypeCatalog=<span class="built_in">local</span></span><br></pre></td></tr></table></figure><h3 id="2-编译源代码"><a href="#2-编译源代码" class="headerlink" title="2. 编译源代码"></a>2. 编译源代码</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn compile</span><br></pre></td></tr></table></figure><h3 id="3-编译测试源代码"><a href="#3-编译测试源代码" class="headerlink" title="3. 编译测试源代码"></a>3. 编译测试源代码</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn <span class="built_in">test</span>-compile</span><br></pre></td></tr></table></figure><h3 id="4-清空"><a href="#4-清空" class="headerlink" title="4. 清空"></a>4. 清空</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean</span><br></pre></td></tr></table></figure><h3 id="5-测试"><a href="#5-测试" class="headerlink" title="5. 测试"></a>5. 测试</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn <span class="built_in">test</span></span><br></pre></td></tr></table></figure><h3 id="6-生成站点目录并打包"><a href="#6-生成站点目录并打包" class="headerlink" title="6. 生成站点目录并打包"></a>6. 生成站点目录并打包</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn site-deploy</span><br></pre></td></tr></table></figure><h3 id="7-安装应用到本地仓库"><a href="#7-安装应用到本地仓库" class="headerlink" title="7. 安装应用到本地仓库"></a>7. 安装应用到本地仓库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn install</span><br></pre></td></tr></table></figure><h3 id="8-打包"><a href="#8-打包" class="headerlink" title="8. 打包"></a>8. 打包</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn package</span><br></pre></td></tr></table></figure><h3 id="9-打jar包"><a href="#9-打jar包" class="headerlink" title="9. 打jar包"></a>9. 打jar包</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn jar:jar</span><br></pre></td></tr></table></figure><h3 id="10-生成eclipse项目"><a href="#10-生成eclipse项目" class="headerlink" title="10. 生成eclipse项目"></a>10. 生成eclipse项目</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn eclipse:eclipse</span><br></pre></td></tr></table></figure><h3 id="11-帮助信息"><a href="#11-帮助信息" class="headerlink" title="11. 帮助信息"></a>11. 帮助信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn <span class="built_in">help</span>:<span class="built_in">help</span></span><br></pre></td></tr></table></figure><h3 id="12-查看项目类型"><a href="#12-查看项目类型" class="headerlink" title="12. 查看项目类型"></a>12. 查看项目类型</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn archetype:generate -DarchetypeCatalog=intrenal</span><br></pre></td></tr></table></figure><h3 id="13-获取当前项目的版本号并输出到指定文件中"><a href="#13-获取当前项目的版本号并输出到指定文件中" class="headerlink" title="13. 获取当前项目的版本号并输出到指定文件中"></a>13. 获取当前项目的版本号并输出到指定文件中</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn org.apache.maven.plugins:maven-help-plugin:3.1.0:evaluate -Dexpression=project.version -q -DforceStdout &gt; version</span><br></pre></td></tr></table></figure><h3 id="14-自动升级项目版本号"><a href="#14-自动升级项目版本号" class="headerlink" title="14. 自动升级项目版本号"></a>14. 自动升级项目版本号</h3><p>该命令适用于自动化的脚本当中，譬如项目当前版本号为1.0.0-snapshot，执行该命令后最小数位的版本号会自动加1变为1.0.1-snapshot，如果版本号有任意多个位数，按照下例中的格式创建即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mvn </span><br><span class="line">build-helper:parse-version //构建版本号的插件</span><br><span class="line">versions:<span class="built_in">set</span> //mvn-release插件</span><br><span class="line">-DnewVersion=<span class="variable">$&#123;parsedVersion.majorVersion&#125;</span>.<span class="variable">$&#123;parsedVersion.minorVersion&#125;</span>.<span class="variable">$&#123;parsedVersion.nextIncrementalVersion&#125;</span>-SNAPSHOT //版本号创建规则</span><br><span class="line">versions:commit //提交当前修改</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-创建项目&quot;&gt;&lt;a href=&quot;#1-创建项目&quot; class=&quot;headerlink&quot; title=&quot;1. 创建项目&quot;&gt;&lt;/a&gt;1. 创建项目&lt;/h3&gt;&lt;p&gt;命令格式：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;mvn archetype:generate 固定格式&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-DgroupId　组织标识（包名）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-DartifactId　项目名称&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-DarchetypeArtifactId 指定ArchetypeId，maven-archetype-quickstart，创建一个Java Project；&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	maven-archetype-webapp，创建一个Web Project&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-DinteractiveMode　是否使用交互模式&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-DarchetypeCatalog=&lt;span class=&quot;built_in&quot;&gt;local&lt;/span&gt; 离线模式&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="java" scheme="https://wsznd.com/categories/java/"/>
    
      <category term="maven" scheme="https://wsznd.com/categories/java/maven/"/>
    
    
      <category term="maven" scheme="https://wsznd.com/tags/maven/"/>
    
  </entry>
  
</feed>
